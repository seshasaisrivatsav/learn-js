Lexical scope
=============
Using variables in upper defined scope

```
let i = 1;
const func = () => {
    console.log(i)
;
}

const add = (a, b) => {
    return a+b;
}

func();
i=2;
func();
```

JS keeps looking for i until it finds it.

pure function
============
```
const add(a, b)
 {
   return a+b;
 }
```
 
 Pure functions: Take argument and return something
 Non pure function: Make set things elsewhere
 
 func();// returns 1 because of closure
 
Closures
========
A variable that is stored inside which is using from outside scope.
 ```

 let funct;
 
 if (true) {
    let i =1;
    func = () => {
        console.log(i);
    }
    // console.dir(func) // inside scopes, in block, it preserves data
 }
 
 console.log(i); // undefined 
 func(); // returns 1
 ```
 
 Note: We used let as we changed value, so we didn't use const.
 
 - Function holds all it's variables inside
 
 - When javascript scans a function, it figures out data and preserves inside a closure.
 
 - if you do ```console.dir``` you will see a scopes key where you can see the data.
 
 - In interview, if someone asks what's closure
 Ans: JS follows lexical scoping, impure functions can access variables from outside. When lexical scoping is not really available to it, it needs to preserve the lexical scoping inside the function. The function knows what its using and preserves it in a closure.
 

 ```

 let funct;
 
 if (true) {
    let i =1; let k = 2;
    func = () => {
        console.log(i);
    }
     console.dir(func) // scope doesn't have k. it only holds things it needs to do the function.
 }
 
 console.log(i); // undefined 
 func(); // returns 1
 ```
 
 
 - Most places in web, they say closure is inner function, but it's not really true.
 
 
 Case 1
 -------
 Let's have another case with inner function
 - let the function func return an anonymous function
 ```
 const func = () => {
    let i = 1;
    
    return () =>  {
        console.log(i);
    };
 };
 
 let inner = func(); // func returns innter function.
 inner();  // because of the closure, inner will hold it
 
 
 ```
 
 or
, you can just run

currying
-------
```func()();```

example:
-------
```
const add = (a) => {
    return (b) => {
        console.log(a+b);
    };
};

add(1)(2);
```

example of closure asynchronous
--------------------------------
```
for (let i=0; i<4; i++){
    setTimeout(()=> {
        console.log(i);
    }, 1000);
};

```
Returns 1,2,3,4
Note: because of the closure, even though its not inside of for loop,

Interview question: (Closure example)
---------------------
What does the below code return?

```
for (var i=0; i<4; i++){
    setTimeout(()=> {
        console.log(i);
    }, 1000);
};

console.log('after');

```
Ans: 4. // returns only one thing.

Understand what is happening. If you change var to let, you'd get 0,1,2,3. Why are you getting 4 if you change to var?

- Var is function scope : when you do var i, it's not creating new variable every time
- 

You cannot use it like below
```
{
let i = 0;
let i = 1;
let i = 2;
}
```

When you use let, the following happens
```
{
let i = 0;
}
{
let i = 1;
}
{
let i = 2;
}
{
let i = 3;
}
```

When you use var, the following happens
```
{
var i = 0;
}
{
 i = 1;
}
{
 i = 2;
}
{
 i = 3;
}

i= 4
```